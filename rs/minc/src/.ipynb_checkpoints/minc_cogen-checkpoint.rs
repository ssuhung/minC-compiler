use std::cmp;
use std::collections::HashMap;
use crate::minc_ast;

// TODO: 1. Extract cogen_cmd_XXX functions 2. Save the calculation resault to %rax instead of the top of the stack

// This list records the calling convention of x86 architecture,
// the i-th element represent the position of the i-th argument.
// For example, the second argument is saved in rsi register when a function is been called,
// and "16" means the arguments is saved on 16(%rbp)
static ARG_POS: [&str; 20] = ["rdi", "rsi", "rdx", "rcx", "r8", "r9", "16", "24", "32", "40", "48", "56", "64", "72", "80", "88", "96", "104", "112", "120"];


// Transfer the name of register to name in assambly code
// For example:
//     reg_name_to_asm("rax") => "%rax"
//     reg_name_to_asm("8") => "8(%rbp)"
fn reg_name_to_asm(reg_name: &str) -> String {
    let transfer_dict: HashMap<&str, &str> = HashMap::from([
        ("rax", "%rax"),
        ("rcx", "%rcx"),
        ("rdx", "%rdx"),
        ("rbx", "%rbx"),
        ("rsi", "%rsi"),
        ("rdi", "%rdi"),
        ("rsp", "%rsp"),
        ("rbp", "%rbp"),
        ("r8", "%r8"),
        ("r9", "%r9"),
        ("r10", "%r10"),
        ("r11", "%r11"),
        ("r12", "%r12"),
        ("r13", "%r13"),
        ("r14", "%r14"),
        ("r15", "%r15"),
    ]);
    
    if let Some(x) = transfer_dict.get(reg_name) {
        x.to_string()
    }
    else {
        let v: i64 = reg_name.parse().unwrap();
        format!("{v}(%rbp)")
    }
}

// Test if the input string represents an int or not
fn str_is_numeric(string: &str) -> bool {
    for cha in string.chars(){
        if cha == '-' { continue }
        if !cha.is_numeric() { return false; }
    }
    true
}

// The function that returns the assembly code of moving data from from_loc to to_loc
// from_loc and to_loc can be register's names or an intergen that represents the position in the stack
// For example:
//    cogen_cmd_mov("rax", "8") => "\tmov\t%rax, 8(%rbp)\n"
//    cogen_cmd_mov("16", "-8") => "\tmov\t16(%rbp), %rdx\n\tmov\t%rdx, -8(%rbp)\n"
fn cogen_cmd_mov(from_loc: &str, to_loc: &str) -> String {
    if str_is_numeric(from_loc) & str_is_numeric(to_loc) {
        format!("\tmovq\t{}, %rdx\n\tmovq\t%rdx, {}\n", reg_name_to_asm(from_loc), reg_name_to_asm(to_loc))
    }
    else {
        format!("\tmovq\t{}, {}\n", reg_name_to_asm(from_loc), reg_name_to_asm(to_loc))
    }
}

// The function that generates assambly code of the program
pub fn ast_to_asm_program(_program: minc_ast::Program) -> String {
    let mut asm: String = "# assembly generated by minc compiler ...\n".to_owned();
    
    for i in 0.._program.defs.len(){
        let func_asm = cogen_def(&_program.defs[i]);
        asm.push_str(&func_asm);
    }
    asm
}

// The function that generates assambly code of a function
fn cogen_def(_def: &minc_ast::Def) -> String{
    let minc_ast::Def::Fun(func_name, parameters, _return_type, statement) = _def;
    
    // The boilerplate assambly code of a function's start and end
    // First, we have to declare the function name is a function in the assambly,
    // then calls .cfi_startproc and .cfi_endproc at the begining and the end of
    // the function for x86 architecture's safey mechanism.
    // Then we have to save the current %rbp so that we can know the stack frame's
    // range when we return from this function.
    let mut asm_prefix = format!("\t.globl	{func_name}
    .type	{func_name}, @function
{func_name}:
    .cfi_startproc
    pushq	%rbp
    movq	%rsp, %rbp\n");
    let asm_suffix = "\t.cfi_endproc\n";
    
    // env is a dictionary to store pairs of variable names and their locations in the stack
    let mut env: HashMap<String, i64> = HashMap::new();
    // v represents the regien in the stack that is unused
    // For example, if v is -8, then the address below -8(%rbp) is not used
    let v: i64 = -8 * cmp::min(6, parameters.len() as i64);
    // These two variables represent the next index for if and while label's name
    // For example, the name of label related to the first if statement is "IF_END_0",
    // and the next is "IF_END_1", so we need this variable to record it
    let mut next_if_branch_index: i64 = 0;
    let mut next_while_branch_index: i64 = 0;
    
    // The strategy of this compiler is to save all variables in the stack,
    // so the first thing to do is to move arguments that saved in registers
    // to the stack, and then record them in env
    for i in 0..cmp::min(6, parameters.len()) {
        let target_pos = -8 * ((i as i64) + 1);
        let target_pos_str = &format!("{}", target_pos);
        asm_prefix.push_str(&cogen_cmd_mov(ARG_POS[i], target_pos_str));
        env.insert(parameters[i].name.clone(), target_pos);
    }
    asm_prefix.push_str(&format!("\tsubq\t${}, %rsp\n", cmp::min(6, parameters.len()) * 8));
    // If this function has more than 6 arguments, some of them are already in the stack,
    // so we only have to record them in env
    for i in 6..parameters.len() {
        let target_pos_str = ARG_POS[i];
        let target_pos: i64 = target_pos_str.parse().unwrap();
        env.insert(parameters[i].name.clone(), target_pos);
    }
    
    let asm_content = &cogen_stmt(statement, v, &mut env, &mut next_if_branch_index, &mut next_while_branch_index);

    return format!("{asm_prefix}{asm_content}{asm_suffix}")
}

// The function that generates assambly code of a statement
fn cogen_stmt(_stmt: &minc_ast::Stmt, v: i64, env: &mut HashMap<String, i64>, next_if_branch_index: &mut i64, next_while_branch_index: &mut i64) -> String{
    match _stmt {
        minc_ast::Stmt::Empty => "".to_string(),
        // The index of current while branch is "next_while_branch_index - 1"
        // Continue keyword means jump to check the condition directly
        minc_ast::Stmt::Continue => { format!("\tjmp\tWHILE_COND_{}\n", *next_while_branch_index - 1) },
        // Breack keyword means jump out of current while loop, so just jump to WHILE_END_i in assambly
        minc_ast::Stmt::Break => { format!("\tjmp\tWHILE_END_{}\n", *next_while_branch_index - 1) },
        minc_ast::Stmt::Return(expr) => {
            let mut asm = cogen_expt(expr, v, env);
            
            if let minc_ast::Expr::Op(op_name, _expr_vec) = &expr {
                if op_name == &"=".to_string() {
                    asm.push_str(&format!("\tleave\n"));
                    asm.push_str(&format!("\tret\n"));
                    return asm
                };
            };
            
            asm.push_str(&format!("\tpopq\t%rax\n"));
            asm.push_str(&format!("\tleave\n"));
            asm.push_str(&format!("\tret\n"));
            asm
        },
        minc_ast::Stmt::Expr(expr) => {
            cogen_expt(&expr, v, env)
        },
        minc_ast::Stmt::Compound(decls, stmts) => {
            // The variables declared here can only be referenced by the following statements,
            // so we copy env and add local variables in this new env
            // Warning: I didn't tackle the situation when there are variables of the same name but
            // declared in different scope. Error occurs when this happen
            let mut env_local = env.clone();
            let mut v_local = v;
            let mut asm: String = String::from("");
            
            // Record the variables declared in this scope, and reserve a space in the stack for it
            for i in 0..decls.len() {
                v_local -= 8;
                env_local.insert(decls[i].name.clone(), v_local);
            }
            asm.push_str(&format!("\tsubq\t${}, %rsp\n", 8 * decls.len()));
            
            for i in 0..stmts.len() {
                asm.push_str(&cogen_stmt(&stmts[i], v_local, &mut env_local, next_if_branch_index, next_while_branch_index));
            }
            asm
        },
        minc_ast::Stmt::If(cond, then_stmt, Some(else_stmt)) => {
            let else_label_name = &format!("ELSE_{next_if_branch_index}");
            let if_end_label_name = &format!("IF_END_{next_if_branch_index}");
            *next_if_branch_index += 1;
            let asm_cond = cogen_expt(&cond, v, env);
            let asm_then_stmt = cogen_stmt(then_stmt, v, env, next_if_branch_index, next_while_branch_index);
            let asm_else_stmt = cogen_stmt(else_stmt, v, env, next_if_branch_index, next_while_branch_index);
            let mut asm: String = format!("{asm_cond}");
            
            asm.push_str(&format!("\tpopq\t%rax\n"));
            asm.push_str(&format!("\tcmp\t$0, %rax\n"));
            asm.push_str(&format!("\tje\t{else_label_name}\n"));
            asm.push_str(&asm_then_stmt);
            asm.push_str(&format!("\tjmp\t{if_end_label_name}\n"));
            asm.push_str(&format!("{else_label_name}:\n"));
            asm.push_str(&asm_else_stmt);
            asm.push_str(&format!("{if_end_label_name}:\n"));
            asm
        },
        minc_ast::Stmt::If(cond, then_stmt, None) => {
            let if_end_label_name = &format!("IF_END_{next_if_branch_index}");
            *next_if_branch_index += 1;
            let asm_cond = cogen_expt(&cond, v, env);
            let asm_then_stmt = cogen_stmt(then_stmt, v, env, next_if_branch_index, next_while_branch_index);
            let mut asm: String = format!("{asm_cond}");
            
            asm.push_str(&format!("\tpopq\t%rax\n"));
            asm.push_str(&format!("\tcmp\t$0, %rax\n"));
            asm.push_str(&format!("\tjz\t{if_end_label_name}\n"));
            asm.push_str(&asm_then_stmt);
            asm.push_str(&format!("{if_end_label_name}:\n"));
            asm
        },
        // The while loop's code can be divided into two parts, while body and while condition,
        // and they are sandwiched by label "WHILE_BODY_i" and "WHILE_COND_i", and "WHILE_COND_i"
        // "WHILE_END_i" separately
        // At the begining of the while loop, there is a jump command that jumps to the while condition,
        // so that the condition will be checked when the first time it enters the loop
        // At the end of while condition part, we test if the condition is true or not, if it's not
        // false, jump to the begining of while body and excute it again
        minc_ast::Stmt::While(cond, body) => {
            let while_body_label_name = format!("WHILE_BODY_{next_while_branch_index}");
            let while_cond_label_name = format!("WHILE_COND_{next_while_branch_index}");
            let while_end_label_name = format!("WHILE_END_{next_while_branch_index}");
            *next_while_branch_index += 1;
            let asm_body: String = cogen_stmt(body, v, env, next_if_branch_index, next_while_branch_index);
            let asm_cond: String = cogen_expt(cond, v, env);
            
            let mut asm = String::from("");
            asm.push_str(&format!("\tjmp\t{while_cond_label_name}\n"));
            asm.push_str(&format!("{while_body_label_name}:\n"));
            asm.push_str(&asm_body);
            asm.push_str(&format!("{while_cond_label_name}:\n"));
            asm.push_str(&asm_cond);
            asm.push_str(&format!("\tpopq\t%rax\n"));
            asm.push_str(&format!("\tcmpq\t$0, %rax\n"));
            asm.push_str(&format!("\tjne\t{while_body_label_name}\n"));
            asm.push_str(&format!("{while_end_label_name}:\n"));
            
            asm
        }
    }
}

// The function that generates assambly code of an expression, and save the result on the top of the stack (except for Op("="))
fn cogen_expt(_expr: &minc_ast::Expr, v: i64, env: &mut HashMap<String, i64>) -> String{
    match _expr {
        // Use immediate in assambly for constant value
        minc_ast::Expr::IntLiteral(val) => {
            format!("\tpushq\t${val}\n")
        },
        // Get the position of the variable from env and save it to the designated position
        minc_ast::Expr::Id(name) => {
            let loc = env.get(name);
            match loc{
                Some(x) => {
                    let mut asm = format!("\tmovq\t{x}(%rbp), %rax\n");
                    asm.push_str(&format!("\tpushq\t%rax\n"));
                    asm
                },
                _ => { format!("\t.ERR_no_variable_named_{}\n", name) }
            }

        },
        minc_ast::Expr::Op(op, args) => {
            // Minus operator can be unitary (-a) or binary (a - b), so we check the number of arguments first
            if args.len() == 1 {
                let expr = cogen_expt(&args[0], v, env);
                
                match op.as_str() {
                    "-" => {
                        let mut asm = format!("{expr}");
                        asm.push_str(&format!("\tpopq\t%rax\n"));
                        asm.push_str(&format!("\tnegq\t%rax\n"));
                        asm.push_str(&format!("\tpushq\t%rax\n"));
                        asm
                    },
                    "!"=> {
                        let mut asm = format!("{expr}");
                        asm.push_str(&format!("\tpopq\t%rax\n"));
                        asm.push_str(&format!("\tcmpq\t$0, %rax\n"));
                        asm.push_str(&format!("\tmovq\t$0, %rax\n"));
                        asm.push_str(&format!("\tsetz\t%al\n"));
                        asm.push_str(&format!("\tpushq\t%rax\n"));
                        asm
                    },
                    _ => { format!("\t.ERR_not_implemented_op\n") },
                }
            }
            else if args.len() == 2 {
                let expr_1 = cogen_expt(&args[0], v, env);
                let expr_2 = cogen_expt(&args[1], v - 8, env);

                match op.as_str() {
                    "+"=> {
                        let mut asm = format!("{expr_1}{expr_2}");
                        asm.push_str(&format!("\tpopq\t%rax\n"));
                        asm.push_str(&format!("\tpopq\t%rcx\n"));
                        asm.push_str(&format!("\taddq\t%rax, %rcx\n"));
                        asm.push_str(&format!("\tpushq\t%rcx\n"));
                        asm
                    },
                    "-" => {
                        let mut asm = format!("{expr_1}{expr_2}");
                        asm.push_str(&format!("\tpopq\t%rax\n"));
                        asm.push_str(&format!("\tpopq\t%rcx\n"));
                        asm.push_str(&format!("\tsubq\t%rax, %rcx\n"));
                        asm.push_str(&format!("\tpushq\t%rcx\n"));
                        asm
                    },
                    "*" => {
                        let mut asm = format!("{expr_1}{expr_2}");
                        asm.push_str(&format!("\tpopq\t%rax\n"));
                        asm.push_str(&format!("\tpopq\t%rcx\n"));
                        asm.push_str(&format!("\timulq\t%rcx\n"));
                        asm.push_str(&format!("\tpushq\t%rax\n"));
                        asm
                    },
                    "/" => {
                        let mut asm = format!("{expr_1}{expr_2}");
                        asm.push_str(&format!("\tmovq\t$0, %rdx\n"));
                        asm.push_str(&format!("\tpopq\t%rcx\n"));
                        asm.push_str(&format!("\tpopq\t%rax\n"));
                        asm.push_str(&format!("\tidivq\t%rcx\n"));
                        asm.push_str(&format!("\tpushq\t%rax\n"));
                        asm
                    },
                    "%" => {
                        let mut asm = format!("{expr_1}{expr_2}");
                        asm.push_str(&format!("\tmovq\t$0, %rdx\n"));
                        asm.push_str(&format!("\tpopq\t%rcx\n"));
                        asm.push_str(&format!("\tpopq\t%rax\n"));
                        asm.push_str(&format!("\tidivq\t%rcx\n"));
                        asm.push_str(&format!("\tpushq\t%rdx\n"));
                        asm
                    },
                    "==" => {
                        let mut asm = format!("{expr_1}{expr_2}");
                        asm.push_str(&format!("\tpopq\t%rcx\n"));
                        asm.push_str(&format!("\tpopq\t%rax\n"));
                        asm.push_str(&format!("\tcmpq\t%rax, %rcx\n"));
                        asm.push_str(&format!("\tmovq\t$0, %rax\n"));
                        asm.push_str(&format!("\tsete\t%al\n"));
                        asm.push_str(&format!("\tpushq\t%rax\n"));
                        asm
                    },
                    "!=" => {
                        let mut asm = format!("{expr_1}{expr_2}");
                        asm.push_str(&format!("\tpopq\t%rax\n"));
                        asm.push_str(&format!("\tpopq\t%rcx\n"));
                        asm.push_str(&format!("\tcmpq\t%rax, %rcx\n"));
                        asm.push_str(&format!("\tmovq\t$0, %rax\n"));
                        asm.push_str(&format!("\tsetne\t%al\n"));
                        asm.push_str(&format!("\tpushq\t%rax\n"));
                        asm
                    },
                    ">" => {
                        let mut asm = format!("{expr_1}{expr_2}");
                        asm.push_str(&format!("\tpopq\t%rax\n"));
                        asm.push_str(&format!("\tpopq\t%rcx\n"));
                        asm.push_str(&format!("\tcmpq\t%rax, %rcx\n"));
                        asm.push_str(&format!("\tmovq\t$0, %rax\n"));
                        asm.push_str(&format!("\tsetg\t%al\n"));
                        asm.push_str(&format!("\tpushq\t%rax\n"));
                        asm
                    },
                    ">=" => {
                        let mut asm = format!("{expr_1}{expr_2}");
                        asm.push_str(&format!("\tpopq\t%rax\n"));
                        asm.push_str(&format!("\tpopq\t%rcx\n"));
                        asm.push_str(&format!("\tcmpq\t%rax, %rcx\n"));
                        asm.push_str(&format!("\tmovq\t$0, %rax\n"));
                        asm.push_str(&format!("\tsetge\t%al\n"));
                        asm.push_str(&format!("\tpushq\t%rax\n"));
                        asm
                    },
                    "<" => {
                        let mut asm = format!("{expr_1}{expr_2}");
                        asm.push_str(&format!("\tpopq\t%rax\n"));
                        asm.push_str(&format!("\tpopq\t%rcx\n"));
                        asm.push_str(&format!("\tcmpq\t%rax, %rcx\n"));
                        asm.push_str(&format!("\tmovq\t$0, %rax\n"));
                        asm.push_str(&format!("\tsetl\t%al\n"));
                        asm.push_str(&format!("\tpushq\t%rax\n"));
                        asm
                    },
                    "<=" => {
                        let mut asm = format!("{expr_1}{expr_2}");
                        asm.push_str(&format!("\tpopq\t%rax\n"));
                        asm.push_str(&format!("\tpopq\t%rcx\n"));
                        asm.push_str(&format!("\tcmpq\t%rax, %rcx\n"));
                        asm.push_str(&format!("\tmovq\t$0, %rax\n"));
                        asm.push_str(&format!("\tsetle\t%al\n"));
                        asm.push_str(&format!("\tpushq\t%rax\n"));
                        asm
                    },
                    "=" => {
                        if let minc_ast::Expr::Id(name) = &args[0]{
                            if let Some(loc) = env.get(name.as_str()) {
                                // Consider the special case of "a = b = c"
                                if let minc_ast::Expr::Op(op_name, _expr_vec) = &args[1]{
                                    if op_name == &"=".to_string() {
                                        let mut asm = format!("{expr_2}");
                                        asm.push_str(&cogen_cmd_mov("rax", &loc.to_string()));
                                        return asm
                                    };
                                };
                                
                                let mut asm = format!("{expr_2}");
                                asm.push_str(&format!("\tpopq\t%rax\n"));
                                asm.push_str(&cogen_cmd_mov("rax", &loc.to_string()));
                                // asm.push_str(&format!("\tpushq\t%rax\n"));
                                asm
                            }
                            else { format!("\t.ERR_not_able_to_assign {op}\n") }
                        }
                        else { format!("\t.ERR_not_able_to_assign {op}\n") }
                    },
                    _ => { format!("\t.ERR_not_implemented_op {op}\n") },
                }
            }
            else { format!("\t.ERR_more_than_two_args_in_ast\n") }
        },
        minc_ast::Expr::Call(fun, args) => {
            let mut asm = "".to_string();
            
            // Calculate args, and place them in the right place as the calling convention
            // Note that we calculate in reversed order, so that the resault will be pushed into
            // the stack in reversed order
            for i in (0..args.len()).rev() {
                asm.push_str(&cogen_expt(&args[i], v + (i as i64)*8, env));
                if i < 6 {
                    asm.push_str(&format!("\tpopq\t{}\n", reg_name_to_asm(ARG_POS[i])));
                }
            }
            
            // Calling the function
            if let minc_ast::Expr::Id(func_name) = &**fun {
                asm.push_str(&format!("\tcall\t{func_name}\n"));
            }
            
            // Move the return value from rax to the stack
            asm.push_str(&format!("\tpushq\t%rax\n"));
            
            asm
        },
        // There is no difference between an expression in parenthesize and an normal expression
        minc_ast::Expr::Paren(expr) => {
            cogen_expt(expr, v, env)
        }
    }
}
